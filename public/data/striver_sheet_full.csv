Topic,ProblemName,Difficulty,TimeComplexity,SpaceComplexity,FilePath
1.Easy,01.Largest_element_in_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\01.Largest_element_in_array.cpp
1.Easy,02.Second_largest_element_in_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\02.Second_largest_element_in_array.cpp
1.Easy,03.Check_if_array_is_sorted_and_rotated.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\03.Check_if_array_is_sorted_and_rotated.cpp
1.Easy,04.Remove_duplicates_from_sorted_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\04.Remove_duplicates_from_sorted_array.cpp
1.Easy,05.Rotate_array_left_by_1place.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\05.Rotate_array_left_by_1place.cpp
1.Easy,06.Rotate_array_left&right_by_k_places.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\06.Rotate_array_left&right_by_k_places.cpp
1.Easy,07.Move_0's_to_end.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\07.Move_0's_to_end.cpp
1.Easy,08.Linear_search.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\08.Linear_search.cpp
1.Easy,09.Union_of_2_sorted_arrays.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\09.Union_of_2_sorted_arrays.cpp
1.Easy,10.Missing_number.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\10.Missing_number.cpp
1.Easy,11.Max_consecutive_1's.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\11.Max_consecutive_1's.cpp
1.Easy,12.Longest_subarray_with_given_sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\12.Longest_subarray_with_given_sum.cpp
1.Easy,13.Find_element_present_only_once.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\1.Easy\13.Find_element_present_only_once.cpp
2.Medium,01.2_sum_problem.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\01.2_sum_problem.cpp
2.Medium,02.Sort_0_1_2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\02.Sort_0_1_2.cpp
2.Medium,03.Majority_element.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\03.Majority_element.cpp
2.Medium,04.Kadane's_algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\04.Kadane's_algorithm.cpp
2.Medium,05.Number_of_subarray_sum_equal_k.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\05.Number_of_subarray_sum_equal_k.cpp
2.Medium,06.Stock_buy_sell.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\06.Stock_buy_sell.cpp
2.Medium,07.Rearange_elements_by_sign.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\07.Rearange_elements_by_sign.cpp
2.Medium,08.Next_permutation.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\08.Next_permutation.cpp
2.Medium,09.Leaders_in_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\09.Leaders_in_array.cpp
2.Medium,10.Longest_consecutive_subsequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\10.Longest_consecutive_subsequence.cpp
2.Medium,11.Set_matrix_0's.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\11.Set_matrix_0's.cpp
2.Medium,12.Rotate_matrix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\12.Rotate_matrix.cpp
2.Medium,13.Spiral_traversal.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\2.Medium\13.Spiral_traversal.cpp
3.Hard,**,Unknown,O(rowIndex),O(rowIndex),Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\01.Pascal_triangle.cpp
3.Hard,02.Majority_element_2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\02.Majority_element_2.cpp
3.Hard,03.3_sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\03.3_sum.cpp
3.Hard,04.4_sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\04.4_sum.cpp
3.Hard,05.Largest_subarray_with_0sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\05.Largest_subarray_with_0sum.cpp
3.Hard,06.Subarrays_with_xor_k.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\06.Subarrays_with_xor_k.cpp
3.Hard,07.Merge_overlapping_subinterval.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\07.Merge_overlapping_subinterval.cpp
3.Hard,08.Merge_2_sorted_array_without_space.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\08.Merge_2_sorted_array_without_space.cpp
3.Hard,09.Repeating_and_missing_numbers.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\09.Repeating_and_missing_numbers.cpp
3.Hard,10.Count_inversions.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\10.Count_inversions.cpp
3.Hard,11.Reverse_pairs.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\11.Reverse_pairs.cpp
3.Hard,12.Maximum_product_subarray.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\12.Maximum_product_subarray.cpp
3.Hard,"Given an array containing N integers and an integer K, find the length of the longest subarray with the sum of the elements equal to K.",Unknown,"The code iterates through the array once, resulting in a time complexity of O(N), where N is the size of the array.","The code uses an unordered map to store the prefix sums and their corresponding indices. In the worst case, all elements of the array could be distinct, leading to a space complexity of O(N) to store the prefix sums in the map.",Strivers-A2Z-DSA-Sheet\01.Arrays\3.Hard\13.Longest_subarray_with_sum_k_containg_+ves_and_-ves.cpp
1D Arrays,01.Find_x_in_sorted_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\01.Find_x_in_sorted_array.cpp
1D Arrays,02.Implement_lower_bound.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\02.Implement_lower_bound.cpp
1D Arrays,03.Implement_lower_upper_bound.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\03.Implement_lower_upper_bound.cpp
1D Arrays,04.Search_insert_position.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\04.Search_insert_position.cpp
1D Arrays,05.Check_If_array_is_sorted.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\05.Check_If_array_is_sorted.cpp
1D Arrays,06.First_and_last_position.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\06.First_and_last_position.cpp
1D Arrays,07.Number_of_occurences.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\07.Number_of_occurences.cpp
1D Arrays,08.Find_peak_element.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\08.Find_peak_element.cpp
1D Arrays,09.Search_in_rotated_sorted_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\09.Search_in_rotated_sorted_array.cpp
1D Arrays,10.Search_in_rotated_sorted_array_with_duplicates.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\10.Search_in_rotated_sorted_array_with_duplicates.cpp
1D Arrays,11.Find_the_minimum_element_in_sorted_rotated_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\11.Find_the_minimum_element_in_sorted_rotated_array.cpp
1D Arrays,12.Find_single_element_in_sorted_array.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\12.Find_single_element_in_sorted_array.cpp
1D Arrays,13.Find_how_many_times_array_is_rotated.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\1D Arrays\13.Find_how_many_times_array_is_rotated.cpp
2D Arrays,1.Row_with_maximum_number_of_1's.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\2D Arrays\1.Row_with_maximum_number_of_1's.cpp
2D Arrays,2.Search_in_sorted_matrix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\2D Arrays\2.Search_in_sorted_matrix.cpp
2D Arrays,3.Search_in_rowwise_sorted_matrix.cpp,Unknown,"The time complexity of this algorithm is O(m + n), where m is the number of rows and n is the number of columns in the matrix.",The space complexity is O(1) since we are using constant extra space.,Strivers-A2Z-DSA-Sheet\02.Binary Search\2D Arrays\3.Search_in_rowwise_sorted_matrix.cpp
2D Arrays,4.Peak_element_in_matrix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\2D Arrays\4.Peak_element_in_matrix.cpp
2D Arrays,5.Matrix_median.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\2D Arrays\5.Matrix_median.cpp
In Search Space,01.Square_root_of_number.cpp,Unknown,O(log(x)),O(1),Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\01.Square_root_of_number.cpp
In Search Space,02.Nth_root_of_integer.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\02.Nth_root_of_integer.cpp
In Search Space,03.Koko_eating_banana.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\03.Koko_eating_banana.cpp
In Search Space,"You are given an integer array bloomDay, an integer m, and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.",Unknown,"The binary search approach takes O(log n), where n is the number of elements in the `bloomDay` array.",The space complexity is O(1) since we are using a constant amount of extra space.,Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\04.Minimum_days_to_make_boquets.cpp
In Search Space,You are given an array of integers nums and an integer threshold. We need to find the smallest divisor,Unknown,O(n log(max(nums))),O(1),Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\05.Find_smallest_integer.cpp
In Search Space,A conveyor belt has packages that must be shipped from one port to another within days days.,Unknown,"O(N log M), where N is the size of the weights array and M is the sum of all the weights.",O(1) as we are using a constant amount of extra space.,Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\06.Capacity_to_ship_packages.cpp
In Search Space,"In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.",Unknown,"O(n log n), where n is the size of the position array. Sorting the array takes O(n log n) time and the binary search takes O(log n) time.","O(1), constant space is used.",Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\08.Aggresive_cows.cpp
In Search Space,"You have N books, each with Ai number of pages. M students need to be allocated contiguous books, with each student getting at least one book. Out of all the permutations, the goal is to find the permutation where the student with the most pages allocated to him gets the minimum number of pages, out of all possible permutations.",Unknown,"O(N log S), where N is the number of books and S is the sum of all the pages in the array. The binary search takes log S iterations, and for each iteration, we check the validity of allocation in O(N) time.","O(1), as we are using a constant amount of extra space.",Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\09.Book_allocation.cpp
In Search Space,"Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split.",Unknown,O(n * log(sum of array)),O(1),Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\10.Split_array_largest.cpp
In Search Space,"Given a sorted array arr of positive integers and an integer k, find the kth positive integer that is missing from the array.",Unknown,"O(log n), where n is the size of the array.",O(1),Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\11.Kth_missing_number.cpp
In Search Space,12.Gas_station.cpp,Unknown,"O(N log M), where N is the number of existing gas stations and M is the range of distances between adjacent gas stations.","O(1), as we are using constant extra space.",Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\12.Gas_station.cpp
In Search Space,13.Median_of_two_sorted_arrays.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\13.Median_of_two_sorted_arrays.cpp
In Search Space,-,Unknown,"O(log(min(N, M)))",O(1),Strivers-A2Z-DSA-Sheet\02.Binary Search\In Search Space\14.Kth_element_of_two_sorted_arrays.cpp
1.Easy,"Given a valid parentheses string `s`, remove the outermost parentheses of every primitive string in the primitive decomposition of `s`.",Unknown,"O(N), where N is the length of the input string `s`.","O(N), where N is the length of the input string `s`.",Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\01.Remove_outer_parenthesis.cpp
1.Easy,"Given an input string s, reverse the order of the words.",Unknown,"O(n), where n is the length of the input string 's'.","O(n), where n is the length of the input string 's'.",Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\02.Reverse_words_in_string.cpp
1.Easy,"You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string """" if no odd integer exists.",Unknown,"O(N), where N is the length of the input string num.",O(1),Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\03.Largest_odd_number_in_string.cpp
1.Easy,Write a function to find the longest common prefix string amongst an array of strings.,Unknown,"O(N*M*log(N)), where N is the number of strings and M is the maximum length of the strings.",O(1),Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\04.Longest_common_prefix.cpp
1.Easy,"Given two strings s and t, determine if they are isomorphic.",Unknown,"O(n), where n is the length of the input strings s and t.","O(m), where m is the number of unique characters in the input strings s and t.",Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\05.Isomorphic_string.cpp
1.Easy,06.Check_for_rotated_string.cpp,Unknown,"The time complexity of this approach is O(N^2), where N is the length of the input strings `s` and `goal`. This is because the `find` function is used to search for the substring `goal` within the concatenated string, which has a time complexity of O(N^2).","The space complexity is O(N), where N is the length of the input string `s`. This is because we create a new string `concat` by concatenating `s` with itself.",Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\06.Check_for_rotated_string.cpp
1.Easy,07.Valid_anagram.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\03.Strings\1.Easy\07.Valid_anagram.cpp
2.Medium,"Given a string s, sort it in decreasing order based on the frequency of the characters.",Unknown,"O(n log n), where n is the length of the string. Building the frequency map takes O(n) time, and the priority queue operations take O(n log n) time.","O(n), where n is the length of the string. The space is used to store the frequency map and the priority queue.",Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\01.Sort_characters_by_frequency.cpp
2.Medium,"Given a VPS represented as a string s, return the nesting depth of s.",Unknown,"O(n), where n is the length of the string `s`.",O(1),Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\02.Max_nesting_depth_of_parenthesis.cpp
2.Medium,"Given a Roman numeral as a string, convert it to an integer.",Unknown,"O(n), where n is the length of the input string `s`.",O(1),Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\03.Roman_to_Integer.cpp
2.Medium,04.Implement_atoi.cpp,Unknown,"The function scans the input string once, resulting in a linear time complexity of O(n), where n is the length of the input string.","The function uses a constant amount of extra space, resulting in constant space complexity, O(1).",Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\04.Implement_atoi.cpp
2.Medium,05.Count_the_number_of_substrings_with_k_unique_characters.cpp,Unknown,"O(N), where N is the length of the input string.","O(K), where K is the number of distinct characters.*/",Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\05.Count_the_number_of_substrings_with_k_unique_characters.cpp
2.Medium,-,Unknown,"O(n^2), where n is the length of the input string `s`. The nested loops iterate over all possible pairs of indices.","O(1), as we are using a constant amount of extra space.",Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\06.Longest_palindromic_substring.cpp
2.Medium,The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\03.Strings\2.Medium\07.Sum_of_beauty_of_all_substrings.cpp
1. Single Linked List,01.Intro_to_linked_list.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\1. Single Linked List\01.Intro_to_linked_list.cpp
1. Single Linked List,02.Inserting_node_to_linked_list.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\1. Single Linked List\02.Inserting_node_to_linked_list.cpp
1. Single Linked List,03.Deleting_node_in_linked_list.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\1. Single Linked List\03.Deleting_node_in_linked_list.cpp
1. Single Linked List,04.Count_the_number_of_nodes_linked_list.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\1. Single Linked List\04.Count_the_number_of_nodes_linked_list.cpp
1. Single Linked List,05.Search_element_in_linked_list.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\1. Single Linked List\05.Search_element_in_linked_list.cpp
2.Doubly Linked List,01.Introduction_to_Double_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\2.Doubly Linked List\01.Introduction_to_Double_LL.cpp
2.Doubly Linked List,02.Insert_node_in_DLL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\2.Doubly Linked List\02.Insert_node_in_DLL.cpp
2.Doubly Linked List,03.Delete_node_in_DLL.cpp,Unknown,"- If the node to be deleted is the head node (position 1), the code performs a constant number of operations, resulting in a time complexity of O(1).","- The code uses a constant amount of extra space for variables (`temp`, `previous`). Hence, the space complexity is O(1).",Strivers-A2Z-DSA-Sheet\04.Linked List\2.Doubly Linked List\03.Delete_node_in_DLL.cpp
2.Doubly Linked List,04.Reverse_DLL.cpp,Unknown,"- The code iterates over each node of the doubly linked list exactly once, performing a constant number of operations for each node. Therefore, the time complexity is O(n), where n is the number of nodes in the linked list.","- The code uses a constant amount of extra space for variables (`curr`, `nxt`, `ans`). Hence, the space complexity is O(1).",Strivers-A2Z-DSA-Sheet\04.Linked List\2.Doubly Linked List\04.Reverse_DLL.cpp
3.Medium Problems of LL,01.Find_mid_of_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\01.Find_mid_of_LL.cpp
3.Medium Problems of LL,02.Reverse_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\02.Reverse_LL.cpp
3.Medium Problems of LL,03.Detect_loop_in_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\03.Detect_loop_in_LL.cpp
3.Medium Problems of LL,04.Start_of_cycle_in_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\04.Start_of_cycle_in_LL.cpp
3.Medium Problems of LL,05.Count_nodes_in_loop.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\05.Count_nodes_in_loop.cpp
3.Medium Problems of LL,06.Check_for_palindrome_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\06.Check_for_palindrome_LL.cpp
3.Medium Problems of LL,07.Odd_even_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\07.Odd_even_LL.cpp
3.Medium Problems of LL,08.Delete_nth_node_from_back.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\08.Delete_nth_node_from_back.cpp
3.Medium Problems of LL,09.Delete_mid_of_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\09.Delete_mid_of_LL.cpp
3.Medium Problems of LL,10.Sort_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\10.Sort_LL.cpp
3.Medium Problems of LL,11.Sort_0_1_2_in_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\11.Sort_0_1_2_in_LL.cpp
3.Medium Problems of LL,12.Add_1_to_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\12.Add_1_to_LL.cpp
3.Medium Problems of LL,13.Add_two_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\3.Medium Problems of LL\13.Add_two_LL.cpp
4.Medium Problems of DLL,01.Delete_nodes_from_dll.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\4.Medium Problems of DLL\01.Delete_nodes_from_dll.cpp
4.Medium Problems of DLL,02.Pair_sum_in_dll.cpp,Unknown,"O(N), where N is the number of nodes in the doubly linked list.",O(1).,Strivers-A2Z-DSA-Sheet\04.Linked List\4.Medium Problems of DLL\02.Pair_sum_in_dll.cpp
4.Medium Problems of DLL,03.Remove_duplicates_from_dll.cpp,Unknown,"O(N), where N is the number of nodes in the linked list.",O(1).,Strivers-A2Z-DSA-Sheet\04.Linked List\4.Medium Problems of DLL\03.Remove_duplicates_from_dll.cpp
5.Hard Promblems of LL,01.Reverse_k_node_in_groups.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\5.Hard Promblems of LL\01.Reverse_k_node_in_groups.cpp
5.Hard Promblems of LL,02.Rotate_LL_k_times.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\5.Hard Promblems of LL\02.Rotate_LL_k_times.cpp
5.Hard Promblems of LL,03.Copy_LL_with_random_pointers.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\5.Hard Promblems of LL\03.Copy_LL_with_random_pointers.cpp
5.Hard Promblems of LL,04.Flatten_LL.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\04.Linked List\5.Hard Promblems of LL\04.Flatten_LL.cpp
1.Get Strong Hold,01.Implement_atoi_via_recursion.cpp,Unknown,"O(N), where N is the length of the string.","O(N), where N is the length of the string (due to the recursive calls).",Strivers-A2Z-DSA-Sheet\05.Recursion\1.Get Strong Hold\01.Implement_atoi_via_recursion.cpp
1.Get Strong Hold,02.Count_good_numbers.cpp,Unknown,O(n) (due to the recursive calls),O(n) (due to the recursive calls),Strivers-A2Z-DSA-Sheet\05.Recursion\1.Get Strong Hold\02.Count_good_numbers.cpp
1.Get Strong Hold,03.Reverse_stack_using_recursion.cpp,Unknown,O(N^2) (due to multiple recursive calls),O(N) (due to the internal stack space used for recursion),Strivers-A2Z-DSA-Sheet\05.Recursion\1.Get Strong Hold\03.Reverse_stack_using_recursion.cpp
1.Get Strong Hold,04.Sort_stack_using_recursion.cpp,Unknown,O(N^2) (due to multiple recursive calls),O(N) (due to the internal stack space used for recursion),Strivers-A2Z-DSA-Sheet\05.Recursion\1.Get Strong Hold\04.Sort_stack_using_recursion.cpp
2.Subsequences Pattern,01.Genereate all valid parenthesis.cpp,Unknown,"O(2^N * N), where N is the given number of pairs of parentheses.","O(N), where N is the given number of pairs of parentheses (for the recursion stack and storing combinations).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\01.Genereate all valid parenthesis.cpp
2.Subsequences Pattern,02.Power set.cpp,Unknown,"O(2^N), where N is the size of the input array 'nums'.","O(N), where N is the size of the input array 'nums' (for the recursion stack and storing subsets).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\02.Power set.cpp
2.Subsequences Pattern,03.Count distinct substrings.cpp,Unknown,"O(2^N), where N is the length of the input string 's'.","O(2^N), where N is the length of the input string 's' (for storing the distinct subsequences in the set).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\03.Count distinct substrings.cpp
2.Subsequences Pattern,04.Count subsets with sum equal to k.cpp,Unknown,"O(N * sum), where N is the size of the array and sum is the given sum.","O(N * sum), where N is the size of the array and sum is the given sum (for recursion stack).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\04.Count subsets with sum equal to k.cpp
2.Subsequences Pattern,05.Subset 1.cpp,Unknown,"O(2^N), where N is the size of the array.","O(N), where N is the size of the array (for recursion stack and storing subset sums).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\05.Subset 1.cpp
2.Subsequences Pattern,06.Subset 2.cpp,Unknown,"O(2^N), where N is the size of the input array nums. This is because there are 2^N possible subsets.","O(N), where N is the size of the input array nums. This is the space required to store the subsets.",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\06.Subset 2.cpp
2.Subsequences Pattern,07.Combination Sum 1.cpp,Unknown,"O(N^target), where N is the size of the array of candidates and target is the target sum. In the worst case, we may have to explore all possible combinations, which is exponential.","O(target), as the maximum depth of the recursion tree is determined by the target sum.",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\07.Combination Sum 1.cpp
2.Subsequences Pattern,08.Combination Sum 2.cpp,Unknown,"O(N * 2^N), where N is the size of the array of candidates. In the worst case, we may have to explore all possible combinations, which is exponential.","O(target), as the maximum depth of the recursion tree is determined by the target sum.",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\08.Combination Sum 2.cpp
2.Subsequences Pattern,09.Combination Sum 3.cpp,Unknown,"O(2^9), as there are 9 available numbers and we have to explore all possible combinations.","O(k), as the maximum depth of the recursion tree is determined by the number of elements to choose (k).",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\09.Combination Sum 3.cpp
2.Subsequences Pattern,10.Letter combinations of phone.cpp,Unknown,"O(3^N * 4^M), where N is the number of digits that map to 3 letters and M is the number of digits that map to 4 letters.","O(N + M), where N is the number of digits that map to 3 letters and M is the number of digits that map to 4 letters.",Strivers-A2Z-DSA-Sheet\05.Recursion\2.Subsequences Pattern\10.Letter combinations of phone.cpp
3.Try Out All Combos,01.Palindrome partioning.cpp,Unknown,"O(N * 2^N), where N is the length of the input string 's'. In the worst case, we can have 2^N possible partitions, and for each partition, we need to check if each substring is a palindrome, which takes O(N) time.","O(N), where N is the length of the input string 's'. The space is used for storing the temporary partition vector and the vector of partitions.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\01.Palindrome partioning.cpp
3.Try Out All Combos,02.Word search in grid.cpp,Unknown,"O(M * N * 4^L), where M is the number of rows, N is the number of columns in the grid, and L is the length of the target word. In the worst case, we traverse the entire grid for each letter in the target word, and we have 4 choices (up, down, left, right) at each step.","O(L), where L is the length of the target word. The space is used for the recursive call stack.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\02.Word search in grid.cpp
3.Try Out All Combos,03.Rat in maze.cpp,Unknown,"O(3^(N^2)), where N is the size of the matrix. In the worst case, each cell can have three possible neighboring cells to explore.","O(N^2), as we are using a vector of strings to store the paths.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\03.Rat in maze.cpp
3.Try Out All Combos,04.M coloring problem.cpp,Unknown,"O(M^N), where M is the number of colors and N is the number of vertices in the graph. In the worst case, we have to try all possible color combinations for all vertices.","O(N), as we are using an array of colors to store the assigned colors for each vertex.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\04.M coloring problem.cpp
3.Try Out All Combos,The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.,Unknown,"O(N!), where N is the input parameter representing the size of the chessboard.","O(N^2), where N is the input parameter representing the size of the chessboard.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\05.N queens.cpp
3.Try Out All Combos,06.Word Break.cpp,Unknown,"O(2^N), where N is the length of the string. In the worst case, we can have 2^N recursive calls.","O(N), where N is the length of the string. The recursion stack can go up to N in the worst case.",Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\06.Word Break.cpp
3.Try Out All Combos,07.Sudoku solver.cpp,Unknown,"The time complexity of the backtracking algorithm for solving a Sudoku puzzle is O(9^(m*n)), where m and n are the number of rows and columns in the board. In the worst case, we have to try all possible combinations.",The space complexity is O(1) as we are using a constant amount of space for the board and temporary variables.,Strivers-A2Z-DSA-Sheet\05.Recursion\3.Try Out All Combos\07.Sudoku solver.cpp
1. Learn Bit Manipulation,01.Bit Manipulation.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\01.Bit Manipulation.cpp
1. Learn Bit Manipulation,02.Check for the ith bit.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\02.Check for the ith bit.cpp
1. Learn Bit Manipulation,03.Check for odd even.cpp,Unknown,O(1),O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\03.Check for odd even.cpp
1. Learn Bit Manipulation,04.Check for the power of 2.cpp,Unknown,O(1),O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\04.Check for the power of 2.cpp
1. Learn Bit Manipulation,05.Set the righmost unset bit.cpp,Unknown,O(1),O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\05.Set the righmost unset bit.cpp
1. Learn Bit Manipulation,06.Swap two numbers without temporary variable.cpp,Unknown,O(1),O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\06.Swap two numbers without temporary variable.cpp
1. Learn Bit Manipulation,07.Divide two numbers using bit maipulation.cpp,Unknown,"O(log n), where n is the absolute value of the dividend",O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\07.Divide two numbers using bit maipulation.cpp
1. Learn Bit Manipulation,08.Count set bit from numbers 1 to n.cpp,Unknown,O(log(n)),O(log(n)),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\1. Learn Bit Manipulation\08.Count set bit from numbers 1 to n.cpp
2. Interview Problems,01. Minimum bit flips.cpp,Unknown,"O(log n), where n is the maximum value between start and goal",O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\2. Interview Problems\01. Minimum bit flips.cpp
2. Interview Problems,02. Exceptionally odd.cpp,Unknown,"O(n), where n is the number of elements in the array",O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\2. Interview Problems\02. Exceptionally odd.cpp
2. Interview Problems,"You are given two integers L and R, your task is to find the XOR of elements of the range [L, R].",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\2. Interview Problems\03. XOR of numbers from L to R.cpp
3. Advanced Maths,01. Prime factors of number.cpp,Unknown,O(sqrt(N)),O(1) (excluding the space required for the output vector),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\3. Advanced Maths\01. Prime factors of number.cpp
3. Advanced Maths,02. All divisors of number.cpp,Unknown,O(sqrt(N)),O(sqrt(N)) (excluding the space required for the output vector),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\3. Advanced Maths\02. All divisors of number.cpp
3. Advanced Maths,03. Sieve of Eratosthenes.cpp,Unknown,O(n log log n),O(n),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\3. Advanced Maths\03. Sieve of Eratosthenes.cpp
3. Advanced Maths,04. Prime factorization using Sieve.cpp,Unknown,O(N log(log N)),O(N),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\3. Advanced Maths\04. Prime factorization using Sieve.cpp
3. Advanced Maths,05. Fast Power.cpp,Unknown,O(log(n)),O(1),Strivers-A2Z-DSA-Sheet\06.Bit Manipulation\3. Advanced Maths\05. Fast Power.cpp
1. Learning,Write a program to implement a Stack using Array. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\01. Implement stack using array.cpp
1. Learning,Implement a Queue using an Array. Queries in the Queue are of the following type:,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\02. Implement queue using array.cpp
1. Learning,Implement a Stack using one queue.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\03. Implement stack using queue.cpp
1. Learning,Implement a Queue using two stacks s1 and s2.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\04. Implement queue using stacks.cpp
1. Learning,You have a linked list and you have to implement the functionalities push and pop of stack using this given linked list. Your task is to use the class as shown in the comments in the code editor and complete the functions push() and pop() to implement a stack.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\05. Implement stack using linked list.cpp
1. Learning,06. Valid Parenthesis.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\06. Valid Parenthesis.cpp
1. Learning,07. Implement min stack.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\1. Learning\07. Implement min stack.cpp
"2. Infix, Postfix, and Prefix",01. Infix to postfix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\01. Infix to postfix.cpp"
"2. Infix, Postfix, and Prefix",02. Infix to prefix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\02. Infix to prefix.cpp"
"2. Infix, Postfix, and Prefix",03. Prefix to infix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\03. Prefix to infix.cpp"
"2. Infix, Postfix, and Prefix",04. Prefix to postfix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\04. Prefix to postfix.cpp"
"2. Infix, Postfix, and Prefix",05. Postfix to infix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\05. Postfix to infix.cpp"
"2. Infix, Postfix, and Prefix",06. Postfix to prefix.cpp,Unknown,Unknown,Unknown,"Strivers-A2Z-DSA-Sheet\07.Stack and Queues\2. Infix, Postfix, and Prefix\06. Postfix to prefix.cpp"
3. Monotonic Stack and Queue,The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\01. Next Greater Element.cpp
3. Monotonic Stack and Queue,02. Next Greater Element 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\02. Next Greater Element 2.cpp
3. Monotonic Stack and Queue,03. Previous Smaller Element.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\03. Previous Smaller Element.cpp
3. Monotonic Stack and Queue,04. Trapping Rainwater.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\04. Trapping Rainwater.cpp
3. Monotonic Stack and Queue,05. Sum of subarray minimum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\05. Sum of subarray minimum.cpp
3. Monotonic Stack and Queue,06. Sum of range of all subarray.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\06. Sum of range of all subarray.cpp
3. Monotonic Stack and Queue,07. Remove K elements.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\07. Remove K elements.cpp
3. Monotonic Stack and Queue,08. Largest Rectangle in Histogram.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\08. Largest Rectangle in Histogram.cpp
3. Monotonic Stack and Queue,09. Maximal Rectangle in binary matrix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\09. Maximal Rectangle in binary matrix.cpp
3. Monotonic Stack and Queue,10. Asteroids Collision.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\3. Monotonic Stack and Queue\10. Asteroids Collision.cpp
4. Implementation,01. Sliding window maximum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\4. Implementation\01. Sliding window maximum.cpp
4. Implementation,02. Stock span problem.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\4. Implementation\02. Stock span problem.cpp
4. Implementation,03. Celebrity Problem.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\4. Implementation\03. Celebrity Problem.cpp
4. Implementation,04. LRU Cache.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\07.Stack and Queues\4. Implementation\04. LRU Cache.cpp
1. Medium Problems,"Given a string s, find the length of the longest substring without repeating characters.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\01. Longest Substring Without Repeating Characters.cpp
1. Medium Problems,02. Max Consecutive 1's.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\02. Max Consecutive 1's.cpp
1. Medium Problems,03. Fruit into Baskets.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\03. Fruit into Baskets.cpp
1. Medium Problems,04. Longest Repeating Character.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\04. Longest Repeating Character.cpp
1. Medium Problems,05. Binary Subarrays with Sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\05. Binary Subarrays with Sum.cpp
1. Medium Problems,06. Count the number of nice subarrays.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\06. Count the number of nice subarrays.cpp
1. Medium Problems,07. Number of Substrings Containing all 3 characters.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\07. Number of Substrings Containing all 3 characters.cpp
1. Medium Problems,08. Maximum Points you can obtaln form the card.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\1. Medium Problems\08. Maximum Points you can obtaln form the card.cpp
2. Hard Problems,01. Longest Substring with at most K unique characters.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\2. Hard Problems\01. Longest Substring with at most K unique characters.cpp
2. Hard Problems,02. Count the number of substrings with exactly K unique characters.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\2. Hard Problems\02. Count the number of substrings with exactly K unique characters.cpp
2. Hard Problems,03. Minimum Window Substring.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\08. Sliding Window\2. Hard Problems\03. Minimum Window Substring.cpp
1. Learning,01. Implement min heap.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\1. Learning\01. Implement min heap.cpp
1. Learning,02. Check if array is heap.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\1. Learning\02. Check if array is heap.cpp
1. Learning,03. Convert min heap to max heap.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\1. Learning\03. Convert min heap to max heap.cpp
2. Medium Problems,01. Kth largest element.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\01. Kth largest element.cpp
2. Medium Problems,02. Kth smallest element.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\02. Kth smallest element.cpp
2. Medium Problems,03. Merge K sorted arrays.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\03. Merge K sorted arrays.cpp
2. Medium Problems,04. Merge K sorted Lists.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\04. Merge K sorted Lists.cpp
2. Medium Problems,05. Arrange by rank.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\05. Arrange by rank.cpp
2. Medium Problems,06. Task Scheduler.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\06. Task Scheduler.cpp
2. Medium Problems,07. Divide array into sets of K consecutive number.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\2. Medium Problems\07. Divide array into sets of K consecutive number.cpp
3. Hard Problems,01. Design Twitter.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\01. Design Twitter.cpp
3. Hard Problems,"There are given N ropes of different lengths, we need to connect these ropes into one rope. The cost to connect two ropes is equal to the sum of their lengths. The task is to connect the ropes with the minimum cost. Given an array arr[] containing the lengths of the ropes.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\02. Minimum Cost to join n ropes.cpp
3. Hard Problems,"Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\03. Kth largest element in stream.cpp
3. Hard Problems,Given two integer arrays A and B of size N each. A sum combination is made by adding one element from array A and another element from array B. Return the maximum K valid distinct sum combinations from all the possible sum combinations. Output array must be sorted in non-increasing order.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\04. Maximum K sum combinations.cpp
3. Hard Problems,"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\05. Median in a stream.cpp
3. Hard Problems,"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\09. Heaps\3. Hard Problems\06. Top K frequent elements.cpp
1. Easy,"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\1. Easy\01. Assign Cookies.cpp
1. Easy,"Given weights and values of N items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\1. Easy\02. Fractional Knapsack.cpp
1. Easy,"At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills).",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\1. Easy\03. Lemonade Exchange.cpp
1. Easy,"Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\1. Easy\04. Valid Parenthesis String.cpp
2. Medium,"There is one meeting room in a firm. There are N meetings in the form of (start[i], end[i]) where start[i] is the start time of meeting i and end[i] is the finish time of meeting i.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\01. N Meetings in one room.cpp
2. Medium,"You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\02. Jump Game.cpp
2. Medium,You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\03. Jump Game 2.cpp
2. Medium,"Given arrival and departure times of all trains that reach a railway station, find the minimum number of platforms required for the railway station so that no train is kept waiting.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\04. Minimum Platforms.cpp
2. Medium,"Given a set of N jobs where each job 'i' has a deadline and profit associated with it. Each job takes 1 unit of time to complete, and only one job can be scheduled at a time. We earn the profit associated with a job if and only if the job is completed by its deadline. Find the number of jobs done and the maximum profit.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\05. Job Sequencing Problem.cpp
2. Medium,There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\06. Candy.cpp
2. Medium,"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\07. Insert Interval.cpp
2. Medium,"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\10. Greedy Approach\2. Medium\08. Non Overlapping Intervals.cpp
1. Traversals,"Given an integer 'N', determine the maximum number of nodes present on 'Nth' level in a binary tree.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\01. Introduction to trees.cpp
1. Traversals,"You are given an array nodes. It contains 7 integers, which represents the value of nodes of the binary tree in level order traversal. You are also given a root of the tree which has a value equal to nodes[0].",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\02. Binary Tree representation.cpp
1. Traversals,"Given the root of a binary tree, return the preorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\03. Preorder Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the inorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\04. Inorder Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the postorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\05. Postorder Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\06. Level Order Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the preorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\07. Iterative Preorder Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the inorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\08. Iterative Inorder Traversal.cpp
1. Traversals,"Given the root of a binary tree, return the postorder traversal of its nodes' values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\09. Iterative Postorder.cpp
1. Traversals,"You have been given a Binary Tree of 'N' nodes, where the nodes have integer values.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\1. Traversals\10. All in one traversal.cpp
2. Medium Problems,"Given the root of a binary tree, return its maximum depth.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\01. Height of binary tree.cpp
2. Medium Problems,"Given a binary tree, determine if it is height-balanced.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\02. Balanced Binary Tree.cpp
2. Medium Problems,"Given the root of a binary tree, return the length of the diameter of the tree.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\03. Diameter of Binary Tree.cpp
2. Medium Problems,A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\04. Maximum Path Sum.cpp
2. Medium Problems,"Given the roots of two binary trees p and q, write a function to check if they are the same or not.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\05. Same Tree.cpp
2. Medium Problems,"Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\06. Zig-Zag Traversal.cpp
2. Medium Problems,"Given a Binary Tree, find its Boundary Traversal. The traversal should be in the following order:",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\07. Boundary Traversal.cpp
2. Medium Problems,"Given the root of a binary tree, calculate the vertical order traversal of the binary tree.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\08. Vertical Order Traversal.cpp
2. Medium Problems,"Given a binary tree, print its top view.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\09. Top View.cpp
2. Medium Problems,"Given a binary tree, print its bottom view.",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\10. Bottom View.cpp
2. Medium Problems,"Given the root of a binary tree, imagine yourself standing on the right side of it,",Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\11. Left or Right View.cpp
2. Medium Problems,12. Symmetric Tree.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\11. Binary Trees\2. Medium Problems\12. Symmetric Tree.cpp
3. Hard,**,Unknown,The time complexity of the recursive function is O(N) as we may visit all nodes in the worst case.,The space complexity is O(N) due to the space used by the recursion stack and the path vector.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\01. All root to leaf paths.cpp
3. Hard,02. Lowest Common Ancestor.cpp,Unknown,The time complexity of this approach is O(n) since we may have to visit all nodes of the binary tree in the worst case.,"The space complexity is O(h) for the recursive call stack, where `h` is the height of the binary tree. In the worst case, when the binary tree is skewed, the space complexity becomes O(n).",Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\02. Lowest Common Ancestor.cpp
3. Hard,03. Max width of binary tree.cpp,Unknown,The time complexity of this approach is O(n) since we need to traverse all nodes in the binary tree using BFS.,"The space complexity is O(w) for the queue, where `w` is the maximum width of the binary tree at any level.",Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\03. Max width of binary tree.cpp
3. Hard,04. Check children sum property.cpp,Unknown,The time complexity of this approach is O(n) as we visit each node in the binary tree once during the post-order traversal.,"The space complexity is O(h) due to the recursion stack, where h is the height of the binary tree.",Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\04. Check children sum property.cpp
3. Hard,05. All nodes at distance K.cpp,Unknown,The time complexity of this approach is O(n) since we need to traverse the entire binary tree to build the parent map and perform BFS from the target node.,"The space complexity is O(n) for the parent map and O(k) for the queue used in BFS. In the worst case, when k approaches n, the space complexity becomes O(n).",Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\05. All nodes at distance K.cpp
3. Hard,06. Min time to burn binary tree.cpp,Unknown,"The time complexity of this approach is O(n) since we perform a BFS starting from the target node, visiting all nodes in the binary tree once.",The space complexity is O(n) for the queue and the hash map.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\06. Min time to burn binary tree.cpp
3. Hard,07. Count nodes in complete binary tree.cpp,Unknown,"The time complexity of this approach is O(log^2 n), as we perform binary search on the last level, and at each step, we calculate the height of the left and right subtrees, which takes O(log n) time. We do this operation recursively, so the overall time complexity is O(log^2 n).","The space complexity is O(log n) due to the recursion stack, where n is the height of the complete binary tree.",Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\07. Count nodes in complete binary tree.cpp
3. Hard,08. Construct BT from inorder and preorder.cpp,Unknown,"The time complexity of this approach is O(n), as we visit each node once.",The space complexity is O(n) for the recursive call stack.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\08. Construct BT from inorder and preorder.cpp
3. Hard,09. Construct BT from inorder and postorder.cpp,Unknown,"The time complexity of this approach is O(n), as we visit each node once.",The space complexity is O(n) for the recursive call stack.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\09. Construct BT from inorder and postorder.cpp
3. Hard,11. Morris Preorder Traversal.cpp,Unknown,The time complexity of this approach is O(n) since we visit each node once.,The space complexity is O(1) since we don't use any extra space.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\11. Morris Preorder Traversal.cpp
3. Hard,12. Morris Inorder Traversal.cpp,Unknown,The time complexity of this approach is O(n) since we visit each node once.,The space complexity is O(1) since we don't use any extra space.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\12. Morris Inorder Traversal.cpp
3. Hard,13. Flatten Binary Tree.cpp,Unknown,The time complexity of this approach is O(n) since we visit each node once.,The space complexity is O(1) since we don't use any extra space.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\13. Flatten Binary Tree.cpp
3. Hard,14. Serialize and Deserialize.cpp,Unknown,- Serialization: O(n) - We visit each node once during the serialization process.,O(n) - The space required for the serialized string and the recursion stack.,Strivers-A2Z-DSA-Sheet\11. Binary Trees\3. Hard\14. Serialize and Deserialize.cpp
1. Concept,**,Unknown,O(N),O(1),Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\1. Concept\01. Intro to BST.cpp
1. Concept,**,Unknown,"O(log N) on average for balanced BST, O(N) in the worst case for skewed BST.","O(H), where H is the height of the BST.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\1. Concept\02. Search in BST.cpp
1. Concept,03. Minimum value in BST.cpp,Unknown,"The time complexity of finding the minimum value in a BST is O(h), where 'h' is the height of the BST. In the worst case, the height of a skewed BST could be 'n', but in a balanced BST, the height is log(n), making the average time complexity O(log n).",The space complexity is O(1) as we are not using any extra space.,Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\1. Concept\03. Minimum value in BST.cpp
2. Practice Problems,01. Ceil in BST.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\01. Ceil in BST.cpp
2. Practice Problems,02. Floor in BST.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\02. Floor in BST.cpp
2. Practice Problems,You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\03. Insert into BST.cpp
2. Practice Problems,"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.",Unknown,"O(log n) on average, O(n) in the worst case, where n is the number of nodes in the BST.","O(log n) on average, O(n) in the worst case.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\04. Delete from BST.cpp
2. Practice Problems,"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",Unknown,O(log n + k),O(log n),Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\05. Kth smallest element in BST.cpp
2. Practice Problems,"Given the root of a binary tree, determine if it is a valid binary search tree (BST).",Unknown,O(n),O(h),Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\06. Validate BST.cpp
2. Practice Problems,"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.",Unknown,O(h),O(h),Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\07. LCA in BST.cpp
2. Practice Problems,"Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.",Unknown,O(n),O(h),Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\08. Build BST from Preorder Traversal.cpp
2. Practice Problems,Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):,Unknown,"- The constructor takes O(h) time, where h is the height of the BST, as it traverses the leftmost path in the BST.","- The space complexity is O(h), where h is the height of the BST, as the stack stores the nodes in the leftmost path of the BST.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\09. BST Iterator.cpp
2. Practice Problems,"Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",Unknown,"- The findTarget() function uses two pointers (one for the left and one for the right traversal of the BST) and performs a two pointer traversal of the BST, taking O(n) time, where n is the number of nodes in the BST.","- The space complexity is O(h), where h is the height of the BST, as the stacks store the nodes in the leftmost and rightmost paths of the BST.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\10. Two Sum in BST.cpp
2. Practice Problems,"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.",Unknown,"- The in-order traversal takes O(n) time, where n is the number of nodes in the BST.","- The space complexity is O(h), where h is the height of the BST, as the recursion stack stores the nodes in the leftmost path of the BST.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\11. Recover BST.cpp
2. Practice Problems,Given a binary tree. Find the size of its largest subtree that is a Binary Search Tree.,Unknown,"- The recursive function visits each node once, so the time complexity is O(n), where n is the number of nodes in the binary tree.","- The space complexity is O(h), where h is the height of the binary tree, as the recursion stack stores the nodes in the path from the root to the deepest leaf node.",Strivers-A2Z-DSA-Sheet\12. Binary Search Trees\2. Practice Problems\12. Largest BST in Binary Tree.cpp
1. Learning,-,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\1. Learning\01. Count the number of graphs.cpp
1. Learning,"Given the adjacency matrix representation of an undirected graph, your task is to return the adjacency list of the graph where each adjacency list contains the vertex itself at the first position and then all its adjacent nodes.",Unknown,"- The time complexity is O(m), where m is the number of edges in the graph, as we iterate through each edge once.","- The space complexity is O(n + 2 * m), where n is the number of vertices and 2 * m is the total number of elements in all adjacency lists, as each edge is represented twice (once in the adjacency list of u and once in the adjacency list of v).",Strivers-A2Z-DSA-Sheet\13. Graphs\1. Learning\02. Graph Representation.cpp
1. Learning,"Given a directed graph, perform Breadth First Traversal (BFS) of the graph starting from vertex 0 and visit all the nodes directly or indirectly connected to Node 0.",Unknown,"- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we visit all the vertices and edges.","- The space complexity is O(V), where V is the number of vertices, as we use extra space for the 'vis' vector and the 'q' queue.",Strivers-A2Z-DSA-Sheet\13. Graphs\1. Learning\03. BFS.cpp
1. Learning,"Given a connected undirected graph, perform Depth First Traversal (DFS) of the graph starting from vertex 0 and visit all the nodes directly or indirectly connected to Node 0.",Unknown,"- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we visit all the vertices and edges.","- The space complexity is O(V), where V is the number of vertices, as we use extra space for the 'vis' vector.",Strivers-A2Z-DSA-Sheet\13. Graphs\1. Learning\04. DFS.cpp
2. Traversal Problems,"Given an n x n matrix 'isConnected' representing connections between cities (nodes), find the total number of provinces in the graph.",Unknown,"- The time complexity is O(n^2), where n is the number of cities. We traverse the entire 'isConnected' matrix to construct the adjacency list.","- The space complexity is O(n), where n is the number of cities. We use extra space for the adjacency list and the 'vis' vector.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\01. Count the number of provinces.cpp
2. Traversal Problems,You are given an m x n grid where each cell can have one of three values:,Unknown,O(m * n) - where 'm' is the number of rows and 'n' is the number of columns in the grid.,O(m * n) - due to the queue and the grid.,Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\02. Rotten Oranges.cpp
2. Traversal Problems,03. Flood-Fill Algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\03. Flood-Fill Algorithm.cpp
2. Traversal Problems,04. Detect Cycle in Undirected Graph.cpp,Unknown,"O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we may need to visit all the vertices and edges of the graph.","O(V), where V is the number of vertices. We use an additional array to keep track of visited nodes.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\04. Detect Cycle in Undirected Graph.cpp
2. Traversal Problems,05. 01 Matrix.cpp,Unknown,"O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix.","O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the distance matrix and the queue during BFS.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\05. 01 Matrix.cpp
2. Traversal Problems,06. Surrounded Regions.cpp,Unknown,"O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.","O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\06. Surrounded Regions.cpp
2. Traversal Problems,07. Number of Enclaves.cpp,Unknown,"O(m * n), where m is the number of rows and n is the number of columns in the matrix. In the worst case, we may need to visit all the cells of the matrix during DFS.","O(m * n), where m is the number of rows and n is the number of columns in the matrix. We use additional space for the 'vis' matrix.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\07. Number of Enclaves.cpp
2. Traversal Problems,08. Word Ladder.cpp,Unknown,"O(n^2 * m), where n is the size of wordList and m is the average length of the words in wordList. In the worst case, we may need to compare every pair of words in wordList to create the adjacency list.","O(n^2), where n is the size of wordList. We use additional space for the adjacency list and the visited map.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\08. Word Ladder.cpp
2. Traversal Problems,10. Distinct Islands.cpp,Unknown,"O(n * m), where n is the number of rows and m is the number of columns in the grid. We visit each cell at most once during the DFS.","O(n * m), where n is the number of rows and m is the number of columns in the grid. We use additional space to store the visited status of each cell and the paths of the islands in the set.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\10. Distinct Islands.cpp
2. Traversal Problems,11. Bipartite Graph.cpp,Unknown,"O(V + E), where V is the number of nodes (vertices) in the graph, and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.","O(V), where V is the number of nodes (vertices) in the graph. We use additional space to store the colors of the nodes.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\11. Bipartite Graph.cpp
2. Traversal Problems,12. Detect Cycle in Directed Graph.cpp,Unknown,"O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.","O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the visited status of the nodes.",Strivers-A2Z-DSA-Sheet\13. Graphs\2. Traversal Problems\12. Detect Cycle in Directed Graph.cpp
3. Topo Sort Problems,01. Topological Sorting.cpp,Unknown,"O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We visit each node and each edge exactly once during the DFS.","O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the visited status of the nodes and the topological sorting order.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\01. Topological Sorting.cpp
3. Topo Sort Problems,02. Kahn's Algorithm.cpp,Unknown,"O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. We perform a BFS-like traversal of all nodes and edges.","O(V), where V is the number of vertices (nodes) in the graph. We use additional space to store the indegree of each node and the queue for BFS.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\02. Kahn's Algorithm.cpp
3. Topo Sort Problems,03. Course Scheduler 1.cpp,Unknown,"O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We perform a BFS-like traversal of all nodes and edges.","O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We use additional space to store the adjacency list and indegree of each node.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\03. Course Scheduler 1.cpp
3. Topo Sort Problems,04. Course Scheduler 2.cpp,Unknown,"O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We perform a BFS-like traversal of all nodes and edges.","O(N + E), where N is the number of courses (nodes) and E is the number of prerequisites (edges) in the graph. We use additional space to store the adjacency list and indegree of each node.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\04. Course Scheduler 2.cpp
3. Topo Sort Problems,05. Find Eventual Safe State.cpp,Unknown,"O(N + E), where N is the number of nodes, and E is the number of edges in the graph. We perform a BFS-like traversal of all nodes and edges.","O(N + E), where N is the number of nodes, and E is the number of edges in the graph. We use additional space to store the reverse adjacency list and outdegree of each node.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\05. Find Eventual Safe State.cpp
3. Topo Sort Problems,06. Alien Dictonary.cpp,Unknown,"O(N), where N is the number of words in the dictionary. We iterate through the dictionary once to set the directed edges and indegrees.","O(K), where K is the number of starting alphabets in the standard dictionary. We use additional space to store the directed graph and indegrees.",Strivers-A2Z-DSA-Sheet\13. Graphs\3. Topo Sort Problems\06. Alien Dictonary.cpp
4. Shortest Path Problems,01. Shortest path in Undirected Graph having unit distance.cpp,Unknown,"O(N+M), where N is the number of vertices and M is the number of edges in the graph. We perform a BFS traversal, visiting each vertex and edge once.","O(N), where N is the number of vertices. We use additional space to store the adjacency list, visited array, and the distance array.",Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\01. Shortest path in Undirected Graph having unit distance.cpp
4. Shortest Path Problems,02. Shortest path in DAG.cpp,Unknown,"O(N + M), where N is the number of vertices and M is the number of edges in the graph. The time complexity is dominated by the topological sorting and DP updates.","O(N + M), where N is the number of vertices and M is the number of edges in the graph. We use additional space for the adjacency list, visited array, topological order, and the distance array.",Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\02. Shortest path in DAG.cpp
4. Shortest Path Problems,03. Dijkstra's Algorithm.cpp,Unknown,"O(E + log(V)), where E is the number of edges and V is the number of vertices in the graph. The time complexity is dominated by the priority queue operations in Dijkstra's algorithm.","O(V + E), where V is the number of vertices and E is the number of edges in the graph. We use additional space for the adjacency list, the distance array, and the priority queue.",Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\03. Dijkstra's Algorithm.cpp
4. Shortest Path Problems,04. Shortest Path in binary matrix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\04. Shortest Path in binary matrix.cpp
4. Shortest Path Problems,05. Path with minimum effort.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\05. Path with minimum effort.cpp
4. Shortest Path Problems,06. Cheapest Flights with K stops.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\06. Cheapest Flights with K stops.cpp
4. Shortest Path Problems,07. Network Delay Time.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\07. Network Delay Time.cpp
4. Shortest Path Problems,08. Bellman Ford Algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\08. Bellman Ford Algorithm.cpp
4. Shortest Path Problems,09. Floyd Warshall Algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\09. Floyd Warshall Algorithm.cpp
4. Shortest Path Problems,10. Find city with smallest number of neighbours.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\10. Find city with smallest number of neighbours.cpp
4. Shortest Path Problems,11. Number of ways to arrive the destination with minimum distance.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\4. Shortest Path Problems\11. Number of ways to arrive the destination with minimum distance.cpp
5. MST Problems,01. Prim's Algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\01. Prim's Algorithm.cpp
5. MST Problems,02. Kruskal's Algorithm.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\02. Kruskal's Algorithm.cpp
5. MST Problems,03. Number of Operations to make Network.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\03. Number of Operations to make Network.cpp
5. MST Problems,04. Most stones removed.cpp,Unknown,O(n),O(n) for the Disjoint Set data structure,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\04. Most stones removed.cpp
5. MST Problems,05. Account Merge.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\05. Account Merge.cpp
5. MST Problems,06. Number of islands 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\06. Number of islands 2.cpp
5. MST Problems,07. Making Large Island.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\07. Making Large Island.cpp
5. MST Problems,08. Swim in rising water.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\5. MST Problems\08. Swim in rising water.cpp
6. Other Algorithms,01. Bridges in graph.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\6. Other Algorithms\01. Bridges in graph.cpp
6. Other Algorithms,02. Strongly Connected Components.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\13. Graphs\6. Other Algorithms\02. Strongly Connected Components.cpp
1. Intro to DP,01. Find the nth fibonacci number.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\1. Intro to DP\01. Find the nth fibonacci number.cpp
2. 1D DP,01. Climbing Stairs.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\2. 1D DP\01. Climbing Stairs.cpp
2. 1D DP,02. Frog Jump.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\2. 1D DP\02. Frog Jump.cpp
2. 1D DP,03. Frog K Jumps.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\2. 1D DP\03. Frog K Jumps.cpp
2. 1D DP,04. House Robber.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\2. 1D DP\04. House Robber.cpp
2. 1D DP,05. House Robber 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\2. 1D DP\05. House Robber 2.cpp
3. 2D DP,01. Ninja Training.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\01. Ninja Training.cpp
3. 2D DP,02. Unique Paths.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\02. Unique Paths.cpp
3. 2D DP,03. Unique Paths 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\03. Unique Paths 2.cpp
3. 2D DP,04. Minimum Path Sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\04. Minimum Path Sum.cpp
3. 2D DP,05. Minimum Path in Triangle.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\05. Minimum Path in Triangle.cpp
3. 2D DP,06. Minimum Falling Path Sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\3. 2D DP\06. Minimum Falling Path Sum.cpp
4. DP on Subsequences,01. Subset sum equal to k.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\01. Subset sum equal to k.cpp
4. DP on Subsequences,02. Partition array in two equal sum subsets.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\02. Partition array in two equal sum subsets.cpp
4. DP on Subsequences,03. Minimum Sum Partition.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\03. Minimum Sum Partition.cpp
4. DP on Subsequences,04. Count number of subsets with sum K.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\04. Count number of subsets with sum K.cpp
4. DP on Subsequences,05. Partition with given difference.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\05. Partition with given difference.cpp
4. DP on Subsequences,06. 01 Knapsack.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\06. 01 Knapsack.cpp
4. DP on Subsequences,07. Coin Change.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\07. Coin Change.cpp
4. DP on Subsequences,08. Target Sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\08. Target Sum.cpp
4. DP on Subsequences,09. Coin Change 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\09. Coin Change 2.cpp
4. DP on Subsequences,10. Unbounded Knapsack.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\10. Unbounded Knapsack.cpp
4. DP on Subsequences,11. Rod Cutting Problem.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\4. DP on Subsequences\11. Rod Cutting Problem.cpp
5. DP on Strings,01. Longest Common Subsequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\01. Longest Common Subsequence.cpp
5. DP on Strings,02. Print the LCS.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\02. Print the LCS.cpp
5. DP on Strings,03. Longest Common Substring.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\03. Longest Common Substring.cpp
5. DP on Strings,04. Longest Palindromic Subsequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\04. Longest Palindromic Subsequence.cpp
5. DP on Strings,05. Minimum steps to make string palindrome.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\05. Minimum steps to make string palindrome.cpp
5. DP on Strings,06. Minimum steps to make other string.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\06. Minimum steps to make other string.cpp
5. DP on Strings,07. Shortest Common Supersequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\07. Shortest Common Supersequence.cpp
5. DP on Strings,08. Distinct Subsequences.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\08. Distinct Subsequences.cpp
5. DP on Strings,09. Wildcard Matching.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\5. DP on Strings\09. Wildcard Matching.cpp
6. DP on Stocks,01. Best time to buy and sell stocks.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\01. Best time to buy and sell stocks.cpp
6. DP on Stocks,02. Best time to buy and sell stock 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\02. Best time to buy and sell stock 2.cpp
6. DP on Stocks,03. Best time to buy and sell stock upto 2 transaction.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\03. Best time to buy and sell stock upto 2 transaction.cpp
6. DP on Stocks,04. Best time to buy and sell stock uoto k transaction.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\04. Best time to buy and sell stock uoto k transaction.cpp
6. DP on Stocks,05. Buy and sell stocks with cooldown.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\05. Buy and sell stocks with cooldown.cpp
6. DP on Stocks,06. Buy and sell stocks with transaction fee.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\6. DP on Stocks\06. Buy and sell stocks with transaction fee.cpp
7. DP on LIS,01. Longest Increasing Subsequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\7. DP on LIS\01. Longest Increasing Subsequence.cpp
7. DP on LIS,02. Print LIS.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\7. DP on LIS\02. Print LIS.cpp
7. DP on LIS,03. Largest Divisible Subset.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\7. DP on LIS\03. Largest Divisible Subset.cpp
7. DP on LIS,04. Longest Bitonic Subsequence.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\7. DP on LIS\04. Longest Bitonic Subsequence.cpp
7. DP on LIS,05. Number of LIS.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\7. DP on LIS\05. Number of LIS.cpp
8. DP on Partition,01. MCM.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\8. DP on Partition\01. MCM.cpp
8. DP on Partition,02. Minimum cost to cut stick.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\8. DP on Partition\02. Minimum cost to cut stick.cpp
8. DP on Partition,03. Burst Ballons.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\8. DP on Partition\03. Burst Ballons.cpp
8. DP on Partition,05. Palindorme Partionting 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\8. DP on Partition\05. Palindorme Partionting 2.cpp
8. DP on Partition,06. Partition array for maximum sum.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\8. DP on Partition\06. Partition array for maximum sum.cpp
9. DP on Squares,01. Maximal Square.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\9. DP on Squares\01. Maximal Square.cpp
9. DP on Squares,02. Count square submatrices.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\14. Dynamic Programming\9. DP on Squares\02. Count square submatrices.cpp
1. Theory,01. Implement Trie (Prefix Tree).cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\1. Theory\01. Implement Trie (Prefix Tree).cpp
2. Problems,01. Implement Trie 2.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\2. Problems\01. Implement Trie 2.cpp
2. Problems,02. Complete String.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\2. Problems\02. Complete String.cpp
2. Problems,03. Count distinct subsitrings.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\2. Problems\03. Count distinct subsitrings.cpp
2. Problems,04. Bitwise basic operations.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\2. Problems\04. Bitwise basic operations.cpp
2. Problems,05. Maximum XOR of two numbers.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\15. Tries\2. Problems\05. Maximum XOR of two numbers.cpp
Hard,01. Minimum number of insertions to make parenthesis valid.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\16. Strings (Hard)\Hard\01. Minimum number of insertions to make parenthesis valid.cpp
Hard,02. Count and Say.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\16. Strings (Hard)\Hard\02. Count and Say.cpp
Hard,03. KMP or Z string matching algo.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\16. Strings (Hard)\Hard\03. KMP or Z string matching algo.cpp
Hard,04. Longest Happy Prefix.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\16. Strings (Hard)\Hard\04. Longest Happy Prefix.cpp
Hard,05. Shortest Palindrome.cpp,Unknown,Unknown,Unknown,Strivers-A2Z-DSA-Sheet\16. Strings (Hard)\Hard\05. Shortest Palindrome.cpp
